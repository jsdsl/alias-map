{"version":3,"sources":["ts/tests/alias-map.test.ts"],"names":["alias_map_1","require","describe","test","aliasMap","AliasMap","expect","toBeDefined","beforeEach","set","addAliases","get","toBe","each","index","expectedValue","aliases","alias","toBeUndefined","fail","has","toBeTruthy","outerIndex","innerIndex","toBeFalsy","searchAlias","resultSet","beforeAll","listAliases","toContain","toHaveLength","length","not","size","removeValue","clear"],"mappings":"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","file":"alias-map.test.js","sourcesContent":["/*\n *\tCreated by Trevor Sears <trevorsears.main@gmail.com>.\n *\t12:28 PM -- September 24th, 2019.\n *\tProject: JSDSL - Alias Map\n */\n\nimport { AliasMap } from \"../alias-map\";\n\n/**\n * Test cases for {@link AliasMap}.\n *\n * @author Trevor Sears <trevorsears.main@gmail.com>\n * @version v0.1.0\n * @since v0.1.0\n */\ndescribe(\"Initialization\", () => {\n\n\ttest(\"Basic initialization.\", () => {\n\t\t\n\t\tlet aliasMap: AliasMap<string, string> = new AliasMap<string, string>();\n\t\t\n\t\texpect(aliasMap).toBeDefined();\n\t\t\n\t});\n\n});\n\ndescribe(\"Per-method tests.\", () => {\n\t\n\tlet aliasMap: AliasMap<string, string>;\n\t\n\tfunction populate(): void {\n\t\t\n\t\taliasMap.set(\"alias-1-0\", \"alias1value\");\n\t\taliasMap.set(\"alias-2-0\", \"alias2value\");\n\t\taliasMap.set(\"alias-3-0\", \"alias3value\");\n\t\t\n\t\taliasMap.addAliases(\"alias-1-0\", \"alias-1-1\");\n\t\taliasMap.addAliases(\"alias-1-0\", \"alias-1-2\");\n\t\taliasMap.addAliases(\"alias-1-0\", \"alias-1-3\");\n\t\t\n\t\taliasMap.addAliases(\"alias-2-0\", \"alias-2-1\");\n\t\taliasMap.addAliases(\"alias-2-0\", \"alias-2-2\");\n\t\taliasMap.addAliases(\"alias-2-0\", \"alias-2-3\");\n\t\t\n\t\taliasMap.addAliases(\"alias-3-0\", \"alias-3-1\");\n\t\taliasMap.addAliases(\"alias-3-0\", \"alias-3-2\");\n\t\taliasMap.addAliases(\"alias-3-0\", \"alias-3-3\");\n\t\t\n\t}\n\t\n\tbeforeEach(() => {\n\t\t\n\t\taliasMap = new AliasMap<string, string>();\n\t\tpopulate();\n\t\t\n\t});\n\t\n\tdescribe(\"#get\", () => {\n\t\t\n\t\ttest(\"Attempt to retrieve a value via a 'primary alias' succeeds.\", () => {\n\t\t\t\n\t\t\texpect(aliasMap.get(\"alias-1-0\")).toBe(\"alias1value\");\n\t\t\texpect(aliasMap.get(\"alias-2-0\")).toBe(\"alias2value\");\n\t\t\texpect(aliasMap.get(\"alias-3-0\")).toBe(\"alias3value\");\n\t\t\t\n\t\t});\n\t\t\n\t\tdescribe(\"Attempt to retrieve a value via it's 'secondary aliases' succeeds.\", () => {\n\t\t\t\n\t\t\ttest.each([\n\t\t\t\t[1, \"alias1value\", [\"alias-1-1\", \"alias-1-2\", \"alias-1-3\"]],\n\t\t\t\t[2, \"alias2value\", [\"alias-2-1\", \"alias-2-2\", \"alias-2-3\"]],\n\t\t\t\t[3, \"alias3value\", [\"alias-3-1\", \"alias-3-2\", \"alias-3-3\"]]\n\t\t\t])(\"Alias set #%i.\", (index: any, expectedValue: any, aliases: any) => {\n\t\t\t\t\n\t\t\t\tfor (let alias of aliases) expect(aliasMap.get(alias)).toBe(expectedValue);\n\t\t\t\t\n\t\t\t});\n\t\t\t\n\t\t});\n\t\t\n\t\ttest(\"Attempt to retrieve a non-existent value returns undefined.\", () => {\n\t\t\n\t\t\texpect(aliasMap.get(\"alias-4-0\")).toBeUndefined();\n\t\t\texpect(aliasMap.get(\"alias-4-1\")).toBeUndefined();\n\t\t\texpect(aliasMap.get(\"alias-4-2\")).toBeUndefined();\n\t\t\texpect(aliasMap.get(\"alias-4-3\")).toBeUndefined();\n\t\t\t\n\t\t});\n\t\t\n\t});\n\t\n\tdescribe(\"#set\", () => {\n\t\t\n\t\t// TODO [9/25/19 @ 5:33 PM] - Test 'force' parameter.\n\t\n\t\ttest(\"TODO\", () => {\n\t\t\t\n\t\t\tfail(\"Test not yet written...\");\n\t\t\t\n\t\t});\n\t\n\t});\n\t\n\tdescribe(\"#addAliases\", () => {\n\t\n\t\ttest(\"TODO\", () => {\n\t\t\t\n\t\t\tfail(\"Test not yet written...\");\n\t\t\t\n\t\t});\n\t\n\t});\n\t\n\tdescribe(\"#has\", () => {\n\t\n\t\ttest(\"Returns true when called for aliases that have been added via #set.\", () => {\n\t\t\t\n\t\t\texpect(aliasMap.has(\"alias-1-0\")).toBeTruthy();\n\t\t\texpect(aliasMap.has(\"alias-2-0\")).toBeTruthy();\n\t\t\texpect(aliasMap.has(\"alias-3-0\")).toBeTruthy();\n\t\t\t\n\t\t});\n\t\t\n\t\ttest(\"Returns true when called for aliases that have been added via #addAlias.\", () => {\n\t\t\t\n\t\t\tfor (let outerIndex: number = 1; outerIndex < 4; outerIndex++) {\n\t\t\t\t\n\t\t\t\tfor (let innerIndex: number = 1; innerIndex < 4; innerIndex++) {\n\t\t\t\t\t\n\t\t\t\t\texpect(aliasMap.has(\"alias-\" + outerIndex + \"-\" + innerIndex)).toBeTruthy();\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\n\t\t});\n\t\t\n\t\ttest(\"Returns false when called for values not present in the map.\", () => {\n\t\t\t\n\t\t\texpect(aliasMap.has(\"alias-4-0\")).toBeFalsy();\n\t\t\t\n\t\t});\n\t\t\n\t\ttest(\"Returns false for aliases that have been removed via #removeAlias.\", () => {\n\t\t\t\n\t\t\tfail(\"Test not yet written...\");\n\t\t\t\n\t\t});\n\t\t\n\t\ttest(\"Returns false for aliases that have been removed via #removeValue.\", () => {\n\t\t\t\n\t\t\tfail(\"Test not yet written...\");\n\t\t\t\n\t\t});\n\t\n\t});\n\t\n\tdescribe(\"#modify\", () => {\n\t\t\n\t\ttest(\"TODO\", () => {\n\t\t\t\n\t\t\tfail(\"Test not yet written...\");\n\t\t\t\n\t\t});\n\t\t\n\t});\n\t\n\tdescribe(\"#removeAlias\", () => {\n\t\t\n\t\ttest(\"TODO\", () => {\n\t\t\t\n\t\t\tfail(\"Test not yet written...\");\n\t\t\t\n\t\t});\n\t\t\n\t});\n\t\n\tdescribe(\"#removeValue\", () => {\n\t\t\n\t\ttest(\"TODO\", () => {\n\t\t\t\n\t\t\tfail(\"Test not yet written...\");\n\t\t\t\n\t\t});\n\t\t\n\t});\n\t\n\tdescribe(\"#listAliases\", () => {\n\t\t\n\t\tdescribe(\"Correct aliases are returned for a 'primary alias'.\", () => {\n\t\t\t\n\t\t\tdescribe.each([\n\t\t\t\t[1, \"alias-1-0\", [\"alias-1-0\", \"alias-1-1\", \"alias-1-2\", \"alias-1-3\"]],\n\t\t\t\t[2, \"alias-2-0\", [\"alias-2-0\", \"alias-2-1\", \"alias-2-2\", \"alias-2-3\"]],\n\t\t\t\t[3, \"alias-3-0\", [\"alias-3-0\", \"alias-3-1\", \"alias-3-2\", \"alias-3-3\"]]\n\t\t\t])(\"Alias set #%i.\", (index: any, searchAlias: any, aliases: any) => {\n\t\t\t\n\t\t\t\tlet resultSet: string[] | undefined;\n\t\t\t\t\n\t\t\t\tbeforeAll(() => {\n\t\t\t\t\t\n\t\t\t\t\tresultSet = aliasMap.listAliases(searchAlias);\n\t\t\t\t\t\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\ttest(\"Result is well-defined.\", () => {\n\t\t\t\t\t\n\t\t\t\t\texpect(resultSet).toBeDefined();\n\t\t\t\t\t\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\ttest(\"Result contains the correct values.\", () => {\n\t\t\t\t\t\n\t\t\t\t\tfor (let alias of aliases) expect(resultSet).toContain(alias);\n\t\t\t\t\t\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\ttest(\"Result is the appropriate length.\", () => {\n\t\t\t\t\t\n\t\t\t\t\texpect(resultSet).toHaveLength(aliases.length);\n\t\t\t\t\t\n\t\t\t\t});\n\t\t\t\n\t\t\t});\n\t\t\t\n\t\t});\n\t\t\n\t\tdescribe(\"Correct aliases are returned for a 'secondary alias'.\", () => {\n\t\t\t\n\t\t\tdescribe.each([\n\t\t\t\t[1, \"alias-1-1\", [\"alias-1-0\", \"alias-1-1\", \"alias-1-2\", \"alias-1-3\"]],\n\t\t\t\t[2, \"alias-2-2\", [\"alias-2-0\", \"alias-2-1\", \"alias-2-2\", \"alias-2-3\"]],\n\t\t\t\t[3, \"alias-3-3\", [\"alias-3-0\", \"alias-3-1\", \"alias-3-2\", \"alias-3-3\"]]\n\t\t\t])(\"Alias set #%i.\", (index: any, searchAlias: any, aliases: any) => {\n\t\t\t\t\n\t\t\t\tlet resultSet: string[] | undefined;\n\t\t\t\t\n\t\t\t\tbeforeAll(() => {\n\t\t\t\t\t\n\t\t\t\t\tresultSet = aliasMap.listAliases(searchAlias);\n\t\t\t\t\t\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\ttest(\"Result is well-defined.\", () => {\n\t\t\t\t\t\n\t\t\t\t\texpect(resultSet).toBeDefined();\n\t\t\t\t\t\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\ttest(\"Result contains the correct values.\", () => {\n\t\t\t\t\t\n\t\t\t\t\tfor (let alias of aliases) expect(resultSet).toContain(alias);\n\t\t\t\t\t\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\ttest(\"Result is the appropriate length.\", () => {\n\t\t\t\t\t\n\t\t\t\t\texpect(resultSet).toHaveLength(aliases.length);\n\t\t\t\t\t\n\t\t\t\t});\n\t\t\t\t\n\t\t\t});\n\t\t\t\n\t\t});\n\t\t\n\t\tdescribe(\"Included 'search' alias is properly excluded from results when 'includeProvidedAlias' is set \" +\n\t\t\t\t\t   \"to false.\", () => {\n\t\t\t\t\n\t\t\t\tdescribe(\"When searching by 'primary alias'...\", () => {\n\t\t\t\t\t\n\t\t\t\t\tdescribe.each([\n\t\t\t\t\t\t[1, \"alias-1-0\", [\"alias-1-1\", \"alias-1-2\", \"alias-1-3\"]],\n\t\t\t\t\t\t[2, \"alias-2-0\", [\"alias-2-1\", \"alias-2-2\", \"alias-2-3\"]],\n\t\t\t\t\t\t[3, \"alias-3-0\", [\"alias-3-1\", \"alias-3-2\", \"alias-3-3\"]]\n\t\t\t\t\t])(\"Alias set #%i.\", (index: any, searchAlias: any, aliases: any) => {\n\t\t\t\t\t\t\n\t\t\t\t\t\tlet resultSet: string[] | undefined;\n\t\t\t\t\t\t\n\t\t\t\t\t\tbeforeAll(() => {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tresultSet = aliasMap.listAliases(searchAlias, false);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t});\n\t\t\t\t\t\t\n\t\t\t\t\t\ttest(\"Result is well-defined.\", () => {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\texpect(resultSet).toBeDefined();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t});\n\t\t\t\t\t\t\n\t\t\t\t\t\ttest(\"Result contains the correct values.\", () => {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfor (let alias of aliases) expect(resultSet).toContain(alias);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t});\n\t\t\t\t\t\t\n\t\t\t\t\t\ttest(\"Result does NOT contain 'search' alias.\", () => {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\texpect(resultSet).not.toContain(searchAlias);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t});\n\t\t\t\t\t\t\n\t\t\t\t\t\ttest(\"Result is the appropriate length.\", () => {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\texpect(resultSet).toHaveLength(aliases.length);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t});\n\t\t\t\t\t\t\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tdescribe(\"When searching by 'secondary alias'...\", () => {\n\t\t\t\t\t\n\t\t\t\t\tdescribe.each([\n\t\t\t\t\t\t[1, \"alias-1-1\", [\"alias-1-0\", \"alias-1-2\", \"alias-1-3\"]],\n\t\t\t\t\t\t[2, \"alias-2-2\", [\"alias-2-0\", \"alias-2-1\", \"alias-2-3\"]],\n\t\t\t\t\t\t[3, \"alias-3-3\", [\"alias-3-0\", \"alias-3-1\", \"alias-3-2\"]]\n\t\t\t\t\t])(\"Alias set #%i.\", (index: any, searchAlias: any, aliases: any) => {\n\t\t\t\t\t\t\n\t\t\t\t\t\tlet resultSet: string[] | undefined;\n\t\t\t\t\t\t\n\t\t\t\t\t\tbeforeAll(() => {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tresultSet = aliasMap.listAliases(searchAlias, false);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t});\n\t\t\t\t\t\t\n\t\t\t\t\t\ttest(\"Result is well-defined.\", () => {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\texpect(resultSet).toBeDefined();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t});\n\t\t\t\t\t\t\n\t\t\t\t\t\ttest(\"Result contains the correct values.\", () => {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfor (let alias of aliases) expect(resultSet).toContain(alias);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t});\n\t\t\t\t\t\t\n\t\t\t\t\t\ttest(\"Result does NOT contain 'search' alias.\", () => {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\texpect(resultSet).not.toContain(searchAlias);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t});\n\t\t\t\t\t\t\n\t\t\t\t\t\ttest(\"Result is the appropriate length.\", () => {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\texpect(resultSet).toHaveLength(aliases.length);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t});\n\t\t\t\t\t\t\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t});\n\t\t\t\n\t\t});\n\t\t\n\t\ttest(\"Attempts to retrieve a non-existent alias returns undefined.\", () => {\n\t\t\t\n\t\t\texpect(aliasMap.listAliases(\"alias-4-0\")).toBeUndefined();\n\t\t\t\n\t\t});\n\t\n\t});\n\t\n\tdescribe(\"#numberOfAliasesFor\", () => {\n\t\n\t\ttest(\"TODO\", () => {\n\t\t\t\n\t\t\tfail(\"Test not yet written...\");\n\t\t\t\n\t\t});\n\t\n\t});\n\t\n\tdescribe(\"#size\", () => {\n\t\n\t\ttest(\"Returns zero for newly initialized map.\", () => {\n\t\t\t\n\t\t\texpect((new AliasMap()).size()).toBe(0);\n\t\t\t\n\t\t});\n\t\t\n\t\ttest(\"Returns proper size for populated map.\", () => {\n\t\t\t\n\t\t\texpect(aliasMap.size()).toBe(3);\n\t\t\t\n\t\t});\n\t\t\n\t\tdescribe(\"Size updates correctly after adding and removing values.\", () => {\n\t\t\t\n\t\t\ttest(\"Iteration 1 of 3\", () => {\n\t\t\t\t\n\t\t\t\taliasMap.removeValue(\"alias-1-0\");\n\t\t\t\t\n\t\t\t\texpect(aliasMap.size()).toBe(2);\n\t\t\t\t\n\t\t\t});\n\t\t\t\n\t\t\ttest(\"Iteration 2 of 3\", () => {\n\t\t\t\t\n\t\t\t\taliasMap.removeValue(\"alias-1-0\");\n\t\t\t\taliasMap.removeValue(\"alias-2-0\");\n\t\t\t\t\n\t\t\t\texpect(aliasMap.size()).toBe(1);\n\t\t\t\t\n\t\t\t});\n\t\t\t\n\t\t\ttest(\"Iteration 3 of 3\", () => {\n\t\t\t\t\n\t\t\t\taliasMap.removeValue(\"alias-1-0\");\n\t\t\t\taliasMap.removeValue(\"alias-2-0\");\n\t\t\t\taliasMap.removeValue(\"alias-3-0\");\n\t\t\t\t\n\t\t\t\texpect(aliasMap.size()).toBe(0);\n\t\t\t\t\n\t\t\t});\n\t\t\t\n\t\t\ttest(\"TODO\", () => {\n\t\t\t\t\n\t\t\t\t// TODO [9/27/19 @ 6:01 PM] - Add tests for adding values as well.\n\t\t\t\t\n\t\t\t\tfail(\"Test not yet written...\");\n\t\t\t\t\n\t\t\t});\n\t\t\t\n\t\t});\n\t\t\n\t\ttest(\"Size does not change after removing non-existent values from the map.\", () => {\n\t\t\t\n\t\t\taliasMap.removeValue(\"alias-4-0\");\n\t\t\t\n\t\t\texpect(aliasMap.size()).toBe(3);\n\t\t\t\n\t\t});\n\t\n\t});\n\t\n\tdescribe(\"#clear\", () => {\n\t\t\n\t\ttest(\"Method properly 'empties' the AliasMap.\", () => {\n\t\t\t\n\t\t\taliasMap.clear();\n\t\t\t\n\t\t\texpect(aliasMap.size()).toBe(0);\n\t\t\t\n\t\t\tfor (let outerIndex: number = 1; outerIndex < 4; outerIndex++) {\n\t\t\t\t\n\t\t\t\tfor (let innerIndex: number = 0; innerIndex < 4; innerIndex++) {\n\t\t\t\t\t\n\t\t\t\t\texpect(aliasMap.get(\"alias-\" + outerIndex + \"-\" + innerIndex)).toBeUndefined();\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\t\tdescribe(\"Values can be added as expected after a clear operation.\", () => {\n\t\t\n\t\t\ttest(\"TODO\", () => {\n\t\t\t\t\n\t\t\t\tfail(\"Test not yet written...\");\n\t\t\t\t\n\t\t\t});\n\t\t\n\t\t});\n\t\n\t});\n\t\n});"]}